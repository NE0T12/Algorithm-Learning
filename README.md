# Algorithm-Learning



## 二叉搜索树（BST）

- #### 关键操作

  删除：

  在二叉查找树删去一个结点，分三种情况讨论：

  1. 若*p结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
  2. 若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉查找树的特性。
  3. 若*p结点的左子树和右子树均不空。*s为*p左子树的最右下的结点，q为s的双亲结点。在删去*p之后，为保持其它元素之间的相对位置不变，做法如下：
     1. 若q != p，用s代替p，q->rchild = s->lchild
     2. 若q == p, 也用s代替p, q->lchild = s->lchild



---



## 平衡二叉搜索树

### AVL树

AVL树得名于它的发明者[G. M. Adelson-Velsky](https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA)和[E. M. Landis](https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&action=edit&redlink=1)，他们在1962年的论文《An algorithm for the organization of information》中发表了它。

**AVL树**是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。

- #### 时间复杂度

  > 查找、插入和删除在平均和最坏情况下的时间复杂度都是![O(\log{n})](https://wikimedia.org/api/rest_v1/media/math/render/svg/653ab6d6fd99537d220f179d2591955ff4f37b99)。

- #### 平衡

  > 增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

  > 节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。



- #### 关键操作

  1. AVL旋转![avlæ æè½¬çå¾å½¢æè¿°ã](assets/Tree_Rebalancing.png)

  1. 单向右旋平衡处理LL：由于在*a的左子树根节点的左子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作；
  2. 单向左旋平衡处理RR：由于在*a的右子树根节点的右子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作；
  3. 双向旋转（先左后右）平衡处理LR：由于在*a的左子树根节点的右子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
  4. 双向旋转（先右后左）平衡处理RL：由于在*a的右子树根节点的左子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。

- ### 实现

  - ![avl (1)](assets/avl (1).png)

  ​	

  - **删除**参照 `DeleteBST(BiTree &T, KeyType key);`



---

