#include <stdio.h>
#include <iostream>

#define Status bool
#define KeyType int

typedef struct elem
{
	KeyType key;
}ElemType;

typedef struct BiTNode
{
	ElemType data;
	int diff; //平衡因子，左子树高度hl - 右子树高度hr; -1、0、1表示平衡，此外不平衡
	struct BiTNode * lchild;
	struct BiTNode * rchild;
}*BiTree;

Status SearchAVL(BiTree T, KeyType key, BiTree f, BiTree &p);
Status InsertAVL(BiTree &T, ElemType &e);
Status InsertAVL_real(BiTree &T, ElemType &e);
static void rotate_right(BiTree &T);
static void rotate_left(BiTree &T);
static int count_tree_depth(BiTree &T, int depth, int &height); //计算树的高度
static void insert(BiTree &T, ElemType &e);

void PreOrderBiTree(BiTree T);
void MidOrderBiTree(BiTree T);
void LastOrderBiTree(BiTree T);
void printBiTree(BiTree T);
void CreateAVL(BiTree &T);

void CreateAVL(BiTree &T)
{
	ElemType e;
	while (scanf("%d", &e.key) == 1)
		InsertAVL(T, e);
}

void printBiTree(BiTree T)
{
	if (T)
		printf("%d ", T->data.key);
}

void PreOrderBiTree(BiTree T)
{
	printBiTree(T);
	if (T->lchild)
		PreOrderBiTree(T->lchild);
	if (T->rchild)
		PreOrderBiTree(T->rchild);
}

void MidOrderBiTree(BiTree T)
{
	if (T->lchild)
		MidOrderBiTree(T->lchild);
	printBiTree(T);
	if (T->rchild)
		MidOrderBiTree(T->rchild);
}

void LastOrderBiTree(BiTree T)
{
	if (T->lchild)
		LastOrderBiTree(T->lchild);
	if (T->rchild)
		LastOrderBiTree(T->rchild);
	printBiTree(T);
}

Status SearchAVL(BiTree T, KeyType key, BiTree f, BiTree &p)
{
	if (!T)
	{
		p = f;
		return false;
	}
	else if (key == T->data.key)
	{
		p = T;
		return true;
	}
	else if (key < T->data.key)
		return SearchAVL(T->lchild, key, T, p);
	else
		return SearchAVL(T->rchild, key, T, p);
}

Status InsertAVL(BiTree &T, ElemType &e)
{
	if (!T)
	{
		BiTree s = new BiTNode;
		s->data = e; s->lchild = s->rchild = NULL;
		s->diff = 0;
		T = s;
		return true;
	}
	else if (e.key == T->data.key)
		return false;//关键字等于e.key的数据元素，返回e`
	else
		return InsertAVL_real(T, e);

}

Status InsertAVL_real(BiTree &T, ElemType &e)
{
	if (e.key == T->data.key)
		return false;//关键字等于e.key的数据元素，返回e`
	
	int hl = 0, hr = 0;
	T->diff = count_tree_depth(T->lchild, 0, hl) - count_tree_depth(T->rchild, 0, hr);
	
	if (e.key < T->data.key && T->lchild)
	{
		if (1 == T->diff && hl <= 1)	//左左 或 左右
			insert(T, e);
		else
			InsertAVL_real(T->lchild, e);
	}
	else if (e.key > T->data.key && T->rchild)
	{
		if (-1 == T->diff && hr <= 1)	//右右 或 右左
			insert(T, e);
		else
			InsertAVL_real(T->rchild, e);
	}
	else
		insert(T, e);
		

	return true;
}

void insert(BiTree &T, ElemType &e)
{
	BiTree s = new BiTNode;
	s->data = e; s->lchild = s->rchild = NULL;
	s->diff = 0;

	if (0 == T->diff)
	{
		if (e.key < T->data.key)
		{
			T->lchild = s;
			T->diff = 1;
		}
		else
		{
			T->rchild = s;
			T->diff = -1;
		}
	}
	else if (-1 == T->diff)
	{
		T->diff = 0;
		if (e.key < T->data.key)
		{
			T->lchild = s;
		}
		else //需要旋转，右右 或 右左
		{
			if (e.key > T->rchild->data.key)	//右右
			{
				if (T->rchild->rchild)
				{
					if (e.key > T->rchild->rchild->data.key)
						T->rchild->rchild->rchild = s;
					else
						T->rchild->rchild->lchild = s;
				}
				else
					T->rchild->rchild = s;
				
				rotate_left(T);
			}
			else //右左
			{
				if (T->rchild->lchild)
				{
					if (e.key > T->rchild->lchild->data.key)
						T->rchild->lchild->rchild = s;
					else
						T->rchild->lchild->lchild = s;
				}
				else
					T->rchild->lchild = s;

				rotate_right(T->rchild); //先右转
				rotate_left(T);	//再左转
			}
		}
	}
	else if(1 == T->diff)
	{
		T->diff = 0;
		if (e.key > T->data.key)
		{
			T->rchild = s;
		}
		else //需要旋转，左左 或 左右
		{
			if (e.key < T->lchild->data.key)	//左左
			{
				if (T->lchild->lchild)
				{
					if (e.key < T->lchild->lchild->data.key)
						T->lchild->lchild->lchild = s;
					else
						T->lchild->lchild->rchild = s;
				}
				else
					T->lchild->lchild = s;

				rotate_right(T);
			}
			else //左右
			{
				if (T->lchild->rchild)
				{
					if (e.key < T->lchild->rchild->data.key)
						T->lchild->rchild->lchild = s;
					else
						T->lchild->rchild->rchild = s;
				}
				else
					T->lchild->rchild = s;

				rotate_left(T->lchild); //先左转
				rotate_right(T);	//再右转
			}
		}
	}
}

void rotate_left(BiTree &T)
{
	BiTree q = new BiTNode;
	q->data = T->data; q->lchild = T->lchild;
	q->diff = 0;

	BiTree tmp_rchild = T->rchild;
	T->data = tmp_rchild->data;
	
	q->rchild = tmp_rchild->lchild;
	T->lchild = q;
	T->rchild = tmp_rchild->rchild;

	delete tmp_rchild;
}

void rotate_right(BiTree &T)
{
	BiTree q = new BiTNode;
	q->data = T->data; q->rchild = T->rchild;
	q->diff = 0;

	BiTree tmp_lchild = T->lchild;
	T->data = tmp_lchild->data;

	q->lchild = tmp_lchild->rchild;
	T->rchild = q;
	T->lchild = tmp_lchild->lchild;

	delete tmp_lchild;
}

static int count_tree_depth(BiTree &T, int depth, int &height) //计算树的高度
{
	if (!T)
	{
		height = 0;
		return 0;
	}

	if (T->lchild)
		count_tree_depth(T->lchild, depth + 1, height);
	if (T->rchild)
		count_tree_depth(T->rchild, depth + 1, height);
	if (depth > height)
		height = depth;

	return height;
}

void test0()
{
	BiTree T = NULL;

	//create
	CreateAVL(T);
	PreOrderBiTree(T);	printf("\n");
	MidOrderBiTree(T);	printf("\n");

	printf("\n");
	////search
	//BiTree p;
	//bool status;
	//status = SearchBST(T, 2, T, p);
	//printf("search '2':\n");
	//printf("search status: %d\n", status);
	//printf("search result: "); printBST(p); printf("\n");

	//insert
	//ElemType e;
	//e.key = 5;
	//InsertBST(T, e);
	//printf("insert '5':\n");
	//PreOrderBST(T);	printf("\n");
	//MidOrderBST(T);	printf("\n");
	//ElemType e;
	//e.key = 5;
	//bool flag = InsertBST(T, e);
	//printf("insert '5':\n");
	//printf("insert status: %d\n", flag);
	//PreOrderBST(T);	printf("\n");
	//MidOrderBST(T);	printf("\n");

	////delete
	////delete leaf
	//DeleteBST(T, 10);
	//printf("after delete '10': \n");
	////delete tree with right child
	//DeleteBST(T, 9);
	//printf("after delete '9': \n");
	//DeleteBST(T, 5);
	//printf("after delete '5': \n");
	////delete tree with both child
	//DeleteBST(T, 4);
	//printf("after delete '4': \n");
	//DeleteBST(T, 6);
	//printf("after delete '6': \n");
	//DeleteBST(T, 50);
	//printf("after delete '50': \n");
	//PreOrderBST(T);	printf("\n");
	//MidOrderBST(T);	printf("\n");
}

int main()
{
	//freopen("in.txt", "r", stdin);
	//freopen("in1.txt", "r", stdin);
	//freopen("in2.txt", "r", stdin);
	freopen("in3.txt", "r", stdin);

	test0();

	freopen("con", "r", stdin);
	system("pause");
	return 0;
}